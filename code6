//@version=5
strategy("3 Indicator", "3 Indicator", overlay=false, format=format.price, precision=2, default_qty_type=strategy.percent_of_equity, default_qty_value=1)

//-----------------------------------------
// INPUTS
//-----------------------------------------

// -- Candle config
GROUP_CAND = "Config → HARSI Candles"
i_lenHARSI  = input.int(14, "Length", group = GROUP_CAND, tooltip = "RSI Length for HARSI Candles")
i_smoothing = input.int(1, "Open Smoothing", group = GROUP_CAND, minval = 1, maxval = 100)

i_colUp   = input.color(color.teal,  "Up Colour",   group = GROUP_CAND)
i_colDown = input.color(color.red,   "Down Colour", group = GROUP_CAND)
i_colWick = input.color(color.gray,  "Wick Colour", group = GROUP_CAND)

// -- RSI plot config
GROUP_PLOT = "Config → RSI Plot"
i_source    = input.source(hlc3, "Source", group = GROUP_PLOT)
i_lenRSI    = input.int(7, "Length", group = GROUP_PLOT, minval = 1)
i_mode      = input.bool(true, "Smoothed Mode RSI?", group = GROUP_PLOT)
i_showPlot  = input.bool(true, "Show RSI Plot?", group = GROUP_PLOT)
i_showHist  = input.bool(true, "Show RSI Histogram?", group = GROUP_PLOT)

// -- Stochastic RSI config
GROUP_STOCH = "Config → Stochastic RSI Plot"
i_showStoch = input.bool(false, "Show Stochastic?", group = GROUP_STOCH)
i_ribbon    = input.bool(true, "Ribbon?", group = GROUP_STOCH)
i_smoothK   = input.int(3, "Smoothing K", group = GROUP_STOCH, minval = 1)
i_smoothD   = input.int(3, "Smoothing D", group = GROUP_STOCH, minval = 1)
i_stochLen  = input.int(14, "Stochastic Length", group = GROUP_STOCH, minval = 1)
i_stochFit  = input.int(80, "Stoch Scaling %", group = GROUP_STOCH, minval = 1, maxval = 100)

// -- OB / OS Levels
GROUP_CHAN = "Config → OB/OS Boundaries"
i_upper  = input.int(20,  "OB", group = GROUP_CHAN)
i_upperx = input.int(30,  "OB Extreme", group = GROUP_CHAN)
i_lower  = input.int(-20, "OS", group = GROUP_CHAN)
i_lowerx = input.int(-30, "OS Extreme", group = GROUP_CHAN)

//-----------------------------------------
// FUNCTIONS
//-----------------------------------------

f_zrsi(src, len) => ta.rsi(src, len) - 50

f_zstoch(src, length, smooth, scale) =>
    raw = (src - ta.lowest(src, length)) / (ta.highest(src, length) - ta.lowest(src, length)) * 100 - 50
    smoothed = ta.sma(raw, smooth)
    (smoothed / 100) * scale

f_rsi(src, len, smoothMode) =>
    zrsi = f_zrsi(src, len)
    smoothed = 0.0
    smoothed := na(smoothed[1]) ? zrsi : (smoothed[1] + zrsi) / 2
    smoothMode ? smoothed : zrsi

f_rsiHeikinAshi(len) =>
    closeRSI = f_zrsi(close, len)
    openRSI  = nz(closeRSI[1], closeRSI)
    highRSI  = math.max(f_zrsi(high, len), f_zrsi(low, len))
    lowRSI   = math.min(f_zrsi(high, len), f_zrsi(low, len))
    closeHA  = (openRSI + highRSI + lowRSI + closeRSI) / 4
    openHA = 0.0
    openHA := na(openHA[i_smoothing]) ? (openRSI + closeRSI) / 2 : ((openHA[1] * i_smoothing) + closeHA[1]) / (i_smoothing + 1)
    highHA = math.max(highRSI, math.max(openHA, closeHA))
    lowHA  = math.min(lowRSI,  math.min(openHA, closeHA))
    [openHA, highHA, lowHA, closeHA]

//-----------------------------------------
// SERIES
//-----------------------------------------
RSI = f_rsi(i_source, i_lenRSI, i_mode)*4.5+145

StochK = f_zstoch(RSI, i_stochLen, i_smoothK, i_stochFit)
StochD = ta.sma(StochK, i_smoothD)

[O, H, L, C] = f_rsiHeikinAshi(i_lenHARSI)

bodyColour = C > O ? i_colUp : i_colDown

//-----------------------------------------
// PLOTS
//-----------------------------------------
upperx  = hline(i_upperx,  "OB Extreme", color.new(color.silver, 60))
upper   = hline(i_upper,   "OB",         color.new(color.silver, 80))
median  = hline(0,         "Median",     color.orange, hline.style_dotted)
lower   = hline(i_lower,   "OS",         color.new(color.silver, 80))
lowerx  = hline(i_lowerx,  "OS Extreme", color.new(color.silver, 60))

fill(upper, upperx, color.new(color.red,   90))
fill(upper, lower,  color.new(color.blue,  90))
fill(lower, lowerx, color.new(color.green, 90))

plot(i_showHist ? RSI : na, "RSI Histogram", color.new(color.silver, 80), 1, plot.style_histogram)


plot(i_showPlot ? (RSI) : na, "RSI Overlay", color.new(color.rgb(250,200,50), 0), 1)

pk = plot(i_showStoch ? StochK : na, "Stoch K", i_ribbon ? color.new(color.blue, 0) : color.new(color.blue, 0))
pd = plot(i_showStoch ? StochD : na, "Stoch D", i_ribbon ? color.new(color.orange, 0) : color.new(color.orange, 0))
fill(pk, pd, i_ribbon ? (StochK >= StochD ? color.new(color.blue, 50) : color.new(color.orange, 50)) : na)

//-----------------------------------------
// INPUTS
//-----------------------------------------
// ***********************************************************************************************************
// Choose MA type for the base DER calculation .. 
// WMA is my preference and is default .. SMA is really slow and lags a lot - but added for comparison
f_derma(_data, _len, MAOption) =>
    value = 
      MAOption == 'SMA' ? ta.sma(_data, _len) :
      MAOption == 'EMA' ? ta.ema(_data, _len) :
      ta.wma(_data, _len)
// ***********************************************************************************************************


// ===========================================================================================================
//      Inputs
// ===========================================================================================================

price   = close
length  = input.int(15, minval=1)
DER_avg = input.int(5, 'Average', minval=1, inline='DER', group='Directional Energy Ratio')
MA_Type = input.string('WMA', 'DER MA type', options=['WMA', 'EMA', 'SMA'], inline='DER', group='Directional Energy Ratio') 
smooth  = input.int(3, 'Smooth', minval=1,  inline='DER_1', group='Directional Energy Ratio')

show_senti = input.bool(false, 'Sentiment',  inline='DER_s', group='Directional Energy Ratio')
senti   = input.int(20, 'Length', minval=1, inline='DER_s', group='Directional Energy Ratio')


v_calc  = input.string('Relative', 'Calculation', options=['Relative', 'Full', 'None'], group='Volume Parameters')
vlookbk = input.int(20, 'Lookback (for Relative)', minval=1,                            group='Volume Parameters')

// ===========================================================================================================
//          Calculations
// ===========================================================================================================

// Volume Calculation Option  -- will revert to no volume acceleration for instruments with no volume data
// v4.0 => updated Relative Volume calculation fix per @m_b_round

v = volume

vola    = 
  v_calc == 'None' or na(volume) ? 1 : 
  v_calc == 'Relative' ?   ta.stoch(v, v, v, vlookbk) / 100 : 
  v

R       = (ta.highest(2) - ta.lowest(2)) / 2                    // R is the 2-bar average bar range - this method accomodates bar gaps
sr      = ta.change(price) / R                                  // calc ratio of change to R
rsr     = math.max(math.min(sr, 1), -1)                         // ensure ratio is restricted to +1/-1 in case of big moves
c       = fixnan(rsr * vola)                                    // add volume accel -- fixnan adresses cases where no price change between bars

c_plus  = math.max(c, 0)                                        // calc directional vol-accel energy
c_minus = -math.min(c, 0)

// plot(c_plus)
// plot(c_minus)


avg_vola    = f_derma(vola, length, MA_Type)
dem         = f_derma(c_plus, length, MA_Type)  / avg_vola          // directional energy ratio
sup         = f_derma(c_minus, length, MA_Type) / avg_vola

adp         = 100 * ta.wma(dem, DER_avg)                            // average DER
asp         = 100 * ta.wma(sup, DER_avg) *3.8
anp         = adp - asp                                             // net DER..
anp_s       = ta.wma(anp, smooth)

// Calculate Sentiment - a VADER for a longer period and can act as a baseline (compared to a static 0 value)
// note we're not re-calculating vol_avg, demand or supply energy for sentiment. this would've been a different approach
s_adp       = 100 * ta.wma(dem, senti)                            // average DER for sentiment length
s_asp       = 100 * ta.wma(sup, senti)
V_senti     = ta.wma(s_adp - s_asp, smooth)


// ===========================================================================================================
//      Colors & plots
// ===========================================================================================================
c_adp   = color.new(color.aqua, 30)
c_asp   = color.new(color.red, 30)
c_fd    = color.new(color.green, 80)
c_fs    = color.new(color.red, 80)
c_zero  = color.new(#ffee00, 70)

c_up    = color.new(#359bfc, 0)
c_dn    = color.new(#f57f17, 0)

c_sup   = color.new(#33ff00, 80)
c_sdn   = color.new(#ff1111, 80)
up      = anp_s >= 0
s_up    = V_senti >=0 

hline(0, 'Zero Line', c_zero, hline.style_solid)

// =============================================================================
// v3.0 --- Sentiment will be represented as a 4-color histogram
c_grow_above = #1b5e2080 
c_grow_below = #dc4c4a80
c_fall_above = #66bb6a80  
c_fall_below = #ef8e9880     

sflag_up = math.abs(V_senti) >= math.abs(V_senti[1])
// =============================================================================

s = plot(asp, 'Supply Energy', c_asp, 2, style=plot.style_circles,  join=true)
// ===========================================================================================================
//      v2.0 adding alerts 
// ===========================================================================================================

Alert_up    = ta.crossover(anp_s,0)
Alert_dn    = ta.crossunder(anp_s,0)
Alert_swing = ta.cross(anp_s,0)

// "." in alert title for the alerts to show in the right order up/down/swing 
alertcondition(Alert_up,    ".   VADER Crossing 0 Up",      "VADER Up - Buying Energy Detected!")
alertcondition(Alert_dn,    "..  VADER Crossing 0 Down",    "VADER Down - Selling Energy Detected!")
alertcondition(Alert_swing, "... VADER Crossing 0",         "VADER Swing - Possible Reversal")

// ===========================================================================================================
//      v3.0 more alerts for VADER crossing Sentiment
// ===========================================================================================================

v_speedup = ta.crossover(anp_s, V_senti)
v_slowdn  = ta.crossunder(anp_s, V_senti)
alertcondition(v_speedup,   "*  VADER Speeding Up",      "VADER Speeding Up!")
alertcondition(v_slowdn,    "** VADER Slowing Down",    "VADER Slowing Down!")

// indi 3 
stochLength   = input.int(13,  "Stochastic Length", minval = 1)
smoothK_Len   = input.int(5,   "Smooth K", minval = 1)
smoothD_Len   = input.int(5,   "Smooth D", minval = 1)

stochRaw      = ta.stoch(close, high, low, stochLength)
stochLineK    = ta.sma(stochRaw, smoothK_Len)
stochLineD    = ta.sma(stochLineK, smoothD_Len)*3.1+5
plot(stochLineD, "Stoch D", color=color.new(color.green, 0), linewidth=2)


// --- Phần thứ hai ---
percentLevel       = input.int(90, "% Top Level")
warningPercent     = input.int(70, "% Mid Level")
lagShortFactor     = input.float(0.3, "Lag Short Factor")
lagLongFactor      = input.float(0.5, "Lag Long Factor")
lookbackTop        = input.int(144, "Lookback Top")
lookbackBottom     = input.int(144, "Lookback Bottom")

// Hàm Laguerre đổi tên
laguerreFilter(src, gamma) =>
    var float a0 = na
    var float a1 = na
    var float a2 = na
    var float a3 = na
    a0 := (1 - gamma) * src + gamma * nz(a0[1])
    a1 := -gamma * a0 + nz(a0[1]) + gamma * nz(a1[1])
    a2 := -gamma * a1 + nz(a1[1]) + gamma * nz(a2[1])
    a3 := -gamma * a2 + nz(a2[1]) + gamma * nz(a3[1])
    (a0 + 2*a1 + 2*a2 + a3) / 6

lagShortMA   = laguerreFilter(hl2, lagShortFactor)
lagLongMA    = laguerreFilter(hl2, lagLongFactor)

// PPO đổi tên
ppoPos       = (lagShortMA - lagLongMA) / lagLongMA * 100
ppoNeg       = (lagLongMA - lagShortMA) / lagLongMA * 100

// Percent rank đổi tên
percentRankPos = ta.percentrank(ppoPos, lookbackTop)
percentRankNeg = ta.percentrank(ppoNeg, lookbackBottom) * -1

barColorCond = percentRankPos >= percentLevel or (percentRankPos >= warningPercent and percentRankPos < percentLevel)

// Logic cross đổi tên
crossDot = ta.cross(stochLineD, stochLineK) ? stochLineD : na

// Output màu nền đổi tên
tradeSignal = stochLineK >= stochLineD ? 0 : 1
var int check = 0
sellCondition = ta.crossunder(RSI, asp) and RSI < stochLineD
sellCondition1 = RSI < asp and stochLineD < asp and RSI[1] < asp[1] and stochLineD[1] < asp[1] and RSI[2] < asp[2] and stochLineD[2] < asp[2] and RSI[3] < asp[3] and stochLineD[3] < asp[3] and ta.crossunder(RSI, stochLineD)
sellConditionClose = ta.crossover(RSI,stochLineD) or ta.crossover(RSI,asp) 
buyCondition = ta.crossover(RSI,asp) and RSI > stochLineD
buyCondition1 = RSI > asp and stochLineD > asp and RSI[1] > asp[1] and stochLineD[1] > asp[1] and RSI[2] > asp[2] and stochLineD[2] > asp[2] and RSI[3] > asp[3] and stochLineD[3] > asp[3] and ta.crossover(RSI, stochLineD)
buyConditionClose = ta.crossunder(RSI,stochLineD) or ta.crossunder(RSI,asp) 
if (sellCondition1 or sellCondition) and barstate.isconfirmed and check == 0
    strategy.entry("Short", strategy.short)
    alert('{"SYMBOL":"' + syminfo.ticker + '","ACTION":"SELL","CHECK":"NO"}', alert.freq_once_per_bar_close)
    check := 1
if check == 1 and sellConditionClose and barstate.isconfirmed
    strategy.close("Short")
    alert('{"SYMBOL":"' + syminfo.ticker + '","ACTION":"SELL","CHECK":"YES"}', alert.freq_once_per_bar_close)
    check := 0
if (buyCondition1 or buyCondition) and check == 0 and barstate.isconfirmed
    strategy.entry("Long", strategy.long)
    alert('{"SYMBOL":"' + syminfo.ticker + '","ACTION":"BUY","CHECK":"NO"}', alert.freq_once_per_bar_close)
    check := 2
if check == 2 and sellConditionClose and barstate.isconfirmed
    strategy.close("Long")
    alert('{"SYMBOL":"' + syminfo.ticker + '","ACTION":"BUY","CHECK":"YES"}', alert.freq_once_per_bar_close)
    check := 0
